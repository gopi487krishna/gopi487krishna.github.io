[ { "title": "How to Implement a System Call in Linux", "url": "/posts/How-to-Implement-a-System-Call-In-Linux/", "categories": "", "tags": "Saturday-Posts", "date": "2022-11-12 00:00:00 +0530", "snippet": "RIn this post we will learn about how to implement a simple system call in Linux that will print Invoked Hello System Call into the kernel log buffer.BackgroundFollowing files will be modified once we complete the implementation of this System Call : syscall_64.tbl – located under arch/x86/entry/syscallssyscall_64.tbl acts as the registry that kernel uses to maintain the record of all the systemcalls available. The kernel scripts parse this file and associate the system call number with thefunction to be invoked. kernel Makefile – root directory of kernel sourceThis is the main makefile defined in the root directory of the linux-kernel-x folder. When creatinga system call we have 3 options on where to the define the system call itself. If it is related to any subsystem then define the SystemCall inside the perticular folder If it is a miscellaneous system call then define it inside kernel/sys.c Define it inside a seperate directory within the kernel source.We are going with the third option here. So we will define a directory that contains the implementationof the system call and we will link it back to the kernel. In order to link back to the kernel, we will be required to modify the makefile.Steps Open syscall_64.tbl under arch/x86/entry/syscalls and add an entry as shown below/* -- snip -- */450 common set_mempolicy_home_node sys_set_mempolicy_home_node 451 common hello_system_call sys_hello/* -- snip -- */The first value indicates the unique number used to identify that system call. The second valueindicates the ABI ( In our case we dont care if its x86 or amd64 so common ). The third valueindicates the name of the system call which in our case is hello_system_call and fourth valueis the function itself that needs to be invoked when a system call with this number is invoked. Now create a directory named hello_syscall in the root of the linux kernel source and createtwo files in the directory Makefile hello_syscall.c Write the Implementation of system call inside hello_syscall.c#include &amp;lt;linux/kernel.h&amp;gt;#include &amp;lt;linux/syscalls.h&amp;gt;SYSCALL_DEFINE0(hello){ printk(KERN_INFO &quot;Invoked Hello System Call&quot;); return 0;}The SYSCALL_DEFINEN macros allow you to define a system call without getting involved in the details of the function signature.You can implement the system call without using the SYSCALL_DEFINEN macro as well (asmlinkage void ..) but there might be some additionalmetadata passed by your archiecture to the systemcall which you will have to account for explicitly. Therefore it is best to usethese macros to define the system call in a portable manner Now implement the Makefile as followsobj-y := hello_syscall.oWhat this makefile does is that it tells the kernel build system (kbuild) to generate an object file called hello_syscall.o which will be generated from hello_syscall.c or hello_syscall.S (asm file) in the same directory. y here refersto yes it must be built. Other values include- m : Build it as a module- $(CONFIG_**) : The decision for building this file is based on the value set for the kernel config `CONFIG**` Now get back to the root of the kernel source and open the Makefile Navigate to line 1103 or search for the first entry of ifeq ($(KBUILD_EXTMOD),)` in the Makefile There add your system call directory to the list of directories to be built and linked to the kernelifeq ($(KBUILD_EXTMOD),) core-y += kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ hello_syscall/ core-$(CONFIG_BLOCK) += block/ core-$(CONFIG_IO_URING) += io_uring/ Now save the file and and compile and install the kernelmake -j$(nproc)sudo make modules_installsudo cp -v arch/x86_64/boot/bzImage /boot/vmlinuz-***sudo mkinitcpio -k 5.19.9 -g /boot/initramfs-***.imggrub-mkconfig -o /boot/grub/grub.cfgreboot# replace *** with any string like &quot;linux_abc&quot; or version number in both commands(eg. /boot/vmlinuz-linux_abc &amp;amp; initramfs-linux_abc.img) Once you have rebooted the kernel(make sure you boot with the new compiled kernel from advanced options while rebooting), test the systemcall using the following C program#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;sys/syscall.h&amp;gt;#include &amp;lt;linux/kernel.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;errno.h&amp;gt;#define HELLO_SYS_CALL 451int main(){ long sys_call_status; sys_call_status = syscall(HELLO_SYS_CALL); if (!sys_call_status) { printf(&quot;Successfully invoked system call 451\\n&quot;); } return 0;} Compile the file usinggcc -o test test.c Run the compiled file./test Now in the kernel buffer you should see a message printed as shown belowsudo dmesg-- Snip -- [ 4196.683788] Invoked Hello System CallAdditional references Introduction to System Call [ Kbuild System] (https://lwn.net/Articles/21835/) Writing a system call in linux" }, { "title": "My Experience on Building and Using Vim Clutch", "url": "/posts/My-Experience-On-Building-and-using-Vim-Clutch/", "categories": "", "tags": "Saturday-Posts", "date": "2022-10-01 00:00:00 +0530", "snippet": "Few weeks back, I was scrolling through r/Neovim on reddit and noticed a post that mentioned about vim clutch. I got intrigued by the idea of usinga foot pedal to switch modes in vim and decided to give this project a try.So before starting, lets understand what vim clutch is and discuss the motivation behind building such a device.What is VIM Clutch?vim clutch is a footpedal that allows you to go to to insert mode when the pedal is pressed and to normal mode when the pedal is released. It is primarily designed as a means of convenience and to improve the text editing speed of users using vim/neovim.The idea for this device was proposed by Aleksandr LevchukTo give you guys a comparison, you know clutches in cars right? They basically serve as the mechanism for changing gears in a car (They are used for connecting/disconnecting the engine from transmission). Similar to that, vim clutch is used for switching fromone mode to another in vim/neovim.Motivation behind VIM Clutch Pressing ESC causes your hand to move away from homerow resulting in slight discomfort. To improve your typing speed and reduce the strain on ring fingerWhy am I doing it? From the past few months, I have become a hardcore neovim user and have faced this problem of pressing Escapeespecially on a full sized keyboard Because its a fun project and would help me learn something newMy Modifications Pressing the pedal all the time to remain in Insert mode is really a pain. So in my versionthe pedal acts a button where pressing the pedal results in switching to normal mode from any mode In future I plan to use various combinations of presses to trigger different modes and possibly make my life easier.Now that the you have understood the definition and motivation behind this project, lets get to the real stuff and startbuilding this device.Note : The instructions given here were performed on a Gentoo. If you wish to do Arduino development on Gentoo head over tohttps://wiki.gentoo.org/wiki/Arduino to complete the prerequisites.Components Required Arduino Board Electronic Foot Pedal Jumper wiresBuilding the hardwareIts pretty simple, since our footpedal is acting as the switch, Connect the live wire from the footpedal into the 5V rail on your Arduino Board. Connect the ground wire from the footpedal into the ground pin of your Arduino Board. Connect the data wire from the footpedal into the 8th digital pin of your Arduino board.Flashing/Compiling the program to the Arduino Clone the repository from github using this command git clone --recurse-submodules -j8 git@github.com:gopi487krishna/nvim-clutch.git cd into the newly cloned directory Open the file nvim_clutch_sketch.ino in Arduino IDE and upload it to the Arduino BoardWhat the sketch does?const int footpedal_pin = 8; // Digital Pin 8 to Read the Input from Pedalint footpedal_previous_state=0;void setup(){ pinMode(footpedal_pin, INPUT); // We need to recieve data from footpedal Serial.begin(9600);}void loop(){ int footpedal_current_state = digitalRead(footpedal_pin); // Check if pressed or released if(footpedal_current_state == 1 &amp;amp;&amp;amp; footpedal_previous_state != footpedal_current_state){ Serial.println(1); } footpedal_previous_state = footpedal_current_state; delay(20);} Well to give a brief explaination, this code sets the 8th Digital pin as Digital Input and prints 1 into the serial port if the button was pressed. The if condition makes sure that 1 is only sent when the button was pressed. Holding the pedalin pressed state will not send multiple 1 or ON state to the program.Program to send the keyboard eventSome Important Points to Note Here I had a choice to either write a kernel driver or a userspace program to handle the communication.I decided to go with a userspace program since its simple serial communication. To read the data from the serial port, I decided to use a library called CppLinuxSerialIt hides all the complexity of performing serial communication and gives a simple interface to work with serial ports. To send the keyboard sequence, I use a library called libxdo. Its a simple library for simulating keyboard input and mouse activity.And as the clever ones among you guessed it, yes it requires Xorg server to work. My usecase was within a X environment and therefore I decidedto go through this route. You can write a kernel driver to send keyboard sequence directly without requiring an Xorg server. Steps to compile and install the nclutch program Navigate into the github repo that you clone in the previous step. Create a new folder called build cd into that folder and enter cmake -DBUILD_TESTS=OFF .. Now run make to build the program. Run make install to install the program into your systemSome Important Points to Note In order to understand what the program does, please take a look inside nclutch directory. The code is self explanatory in nature and quite easy to follow#include &amp;lt;CppLinuxSerial/SerialPort.hpp&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;xdo.h&amp;gt;int main(int argc, char *argv[]) { std::string filename; if (argc &amp;gt; 1) { filename = std::string(argv[1]); } else { std::cerr &amp;lt;&amp;lt; &quot;Error : Please provide the path to the device\\n&quot;; return EXIT_FAILURE; } /*Screen context*/ xdo_t *x = xdo_new(&quot;:0.0&quot;); if (x == nullptr) { std::cerr &amp;lt;&amp;lt; &quot;Error : Failed to create new instance of xdo\\n &quot;; return EXIT_FAILURE; } mn::CppLinuxSerial::SerialPort serialport( filename, mn::CppLinuxSerial::BaudRate::B_9600, mn::CppLinuxSerial::NumDataBits::EIGHT, mn::CppLinuxSerial::Parity::NONE, mn::CppLinuxSerial::NumStopBits::ONE); /*Block on read and wait until we get atleast 1 byte*/ serialport.SetTimeout(-1); /*Open the file for communication*/ serialport.Open(); std::string readData; // Dummy var for reading a byte while (true) { serialport.Read(readData); /*Send escape key to the focused window*/ xdo_send_keysequence_window(x, CURRENTWINDOW, &quot;Escape&quot;, 0); } serialport.Close(); delete x; return EXIT_SUCCESS;} When running nclutch you are required to pass the device path as the argument. Run sudo dmesg | grep cdc to get the device name Post Installation After building nclutch program, you can create a simple service script to start the program automaticallyafter the system boots In my case, I spawn it as a daemon within my window manager script. Please refer to the documentation of yourwindow manager to understand how to spawn a daemon after startupHow is the experience so far? I use Vim Clutch with my desktop and tbh its an improved experience. I have not become the fastest typist in town but the strain on my ring fingerhas certainly reducedSpecial Thanks !A special thanks to my friend Nikhil Kumar for helping me complete this project. This was my very first attempt at working with hardware stuffand his excellent knowledge in embedded electronics helped me get startedeasily. Also his deep insights on how this project can be improved further(such as using low cost board, introducing new combinations) is reallyinteresting and I am planning to implement them further down the road." }, { "title": "Fixing a non booting kernel based on custom kernel config file", "url": "/posts/Fixing-Non-Booting-Kernel-Based-On-Custom-Config/", "categories": "", "tags": "quickfix", "date": "2022-09-20 00:00:00 +0530", "snippet": "Recently I was trying to migrate my kernel config across Virtual Box, VMware andQemu based VM’s and noticed that in some of the cases, I was not able to bootinto the kernel at all. I did enable vmware, virtual box and qemu specificoptions in the kernel but still the kernel was not booting up (It was booting upon my machine but not on a friend’s machine). Looking deep into the problem Inoticed that the versions of vmware and qemu were different than that of mymachine.Now how to solve this issue?Well, I cannot adjust the config for every version of vmware, qemu or virtualbox, so we need to find a way so that the person using this config can fix it bythemselves. Thats where localmodconfig comes inSo make has a target called localmodconfig that enables all the modules that arecurrently being used by the kernel. It will also deselect the modules which arecurrently not being used by kernel which in turn allows us to create a minimalkernel config. Not only that, localmodconfig can also use the .config filepresent in the kernel build directory. This allows us to have a base kernel withnecessary options already enabled.So lets begin fixing our configStep 1 : Cleaning the KernelWe will start with a fresh build of the kernel so reboot into the default kerneland switch to the kernel build directory and run make mrproper. Invoking thistarget will ensure that all the build artifacts generated during the build willbe removed (including the config file). Step 2 : Copying the config fileCopy the config file into the kernel build directory and rename it to .config.After that run make nconfig or make menuconfig and press escape (and savethe config if a prompt appears). Doing this will update the config file for thekernel version being used.Step 3 : Running localmodconfigRun make localmodconfig to enable modules presently being used by the kernel.If there are no warnings or errors proceed with the kernel compilation (You canrun menuconfig or nconfig to see if important options are enabled).But if there are some warnings saying that the config option is disabled or notpresent go to Step 4Step 4 : Setting additional config optionsLooking at the messages given by local modconfig, we can see that the lastword of these messages contains the config option (starting with CONFIG) thatneeds to be set in the .config file. So just open the file using yourfavourite text editor and add/edit the config options mentioned before and setit to y (or m).Run make menuconfig or make nconfig and save the configfile.If there are too many options to be configured, you can use awk and sed toadd the config options automatically First save the output of localmodconfig in a text file make localmodconfig &amp;gt; add_opts.txt 2&amp;gt;&amp;amp;1 Now run the awk command to get the last column representing the config optionand save it to a new file awk &#39;{print $(NF)}&#39; add_opts.txt &amp;gt; add_opts_cleaned.txt Now to put =y in front of these configs we use the sed command sed -i s/$/=y/ add_opts_cleaned.txt Finally open the file, take a look at if everything is correct and copy pastethe entire content of the file into .config file Now run make menuconfig or make nconfig. These targets will automaticallyset the additional config options required. Now press ESC key on yourkeyboard and save the configuration.Step 5 : Continuing the CompilationContinue the kernel compilation by running make -j$(nproc)ConclusionUsing this method will help you to boot into the kernel. If you want to get a complete list of the kernel modules required (for running everything as per yourrequirements, you can have a look atmodprobed-dbAdditional ReferencesIntroduction to Awk : Learning Awk Is Essential For Linux UsersIntroduction to Sed : Intro to Sed" } ]
